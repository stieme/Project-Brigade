### 一.GO依赖管理工具：

#### 1.govendor:

<mark>:大都不已使用</mark>

![v2-587df4913b9d7ac436e77d0a264892f0_1440w](https://pic1.zhimg.com/80/v2-587df4913b9d7ac436e77d0a264892f0_1440w.webp)



#### 2.GO Modules:

##### 1.特性：

<mark>：可以使包的管理更加简单
：支持版本管理
：允许同一个模块多个版本共存
：可以校验依赖包的哈希值，确保包的一致性，增加安全性
：内置在几乎所有的 go 命令中，包括go get、go build、go install、go run、go test、go list等命令。
：具有 Global Caching 特性，不同项目的相同模块版本，只会在服务器上缓存一份</mark>

##### 2.使用方法：

包（package）；模块（module）元素---集合的关系

```go
import (
    // Go 标准包
    "fmt"
    // 第三方包
    "github.com/spf13/pflag"
    // 匿名包
     _ "github.com/jinzhu/gorm/dialects/mysql"
     // 内部包
    "github.com/marmotedu/iam/internal/apiserver"
)

```

- Go 标准包：在 Go 源码目录下，随 Go 一起发布的包

- 第三方包：第三方提供的包，比如来自于 http://github.com 的包

- 匿名包：只导入而不使用的包。通常情况下，我们只是想使用导入包产生的副作用，即引用包级别的变量、常量、结构体、接口等，以及执行导入包的init()函数

- 内部包：项目内部的包，位于项目目录下
  
  

##### 3.Go Modules命令：

<mark>：Go Modules 的管理命令为go mod，go mod有很多子命令，可以通过go help mod来获取所有的命令</mark>

- download：下载 go.mod 文件中记录的所有依赖包

- edit：编辑 go.mod 文件

- graph：查看现有的依赖结构

- init：把当前目录初始化为一个新模块

- tidy：添加丢失的模块，并移除无用的模块。默认情况下，Go 不会移除 go.mod 文件中的无用依赖。当依赖包不再使用了，可以使用go mod tidy命令来清除它。

- vendor：将所有依赖包存到当前目录下的 vendor 目录下。（......）

- verify：检查当前模块的依赖是否已经存储在本地下载的源代码缓存中，以及检查下载后是否有修改。

- why：查看为什么需要依赖某模块。
  
  

##### 4.go.mod文件：

```go
module github.com/marmotedu/iam

go 1.17

require (
  github.com/AlekSi/pointer v1.1.0
  github.com/appleboy/gin-jwt/v2 v2.6.3
  github.com/asaskevich/govalidator v0.0.0-20200428143746-21a406dcc535
  github.com/gin-gonic/gin v1.6.3
  github.com/golangci/golangci-lint v1.30.0 // indirect
  github.com/google/uuid v1.0.0
    github.com/blang/semver v3.5.0+incompatible
    golang.org/x/text v0.3.2
)

replace (
    github.com/gin-gonic/gin => /home/colin/gin
    golang.org/x/text v0.3.2 => github.com/golang/text v0.3.2
)

exclude (
    github.com/google/uuid v1.1.0
)

```

<mark>：go.mod 文件中包含了 4 个语句，分别是 module、require、replace 和 exclude。</mark>

- module：用来定义当前项目的模块路径。

- go：用来设置预期的 Go 版本，目前只是起标识作用

- require：用来设置一个特定的模块版本，格式为<导入包路径> <版本>

- exclude：用来从使用中排除一个特定的模块版本，如果我们知道模块的某个版本有严重的问题，就可以使用 exclude 将该版本排除掉。

- replace：用来将一个模块版本替换为另外一个模块版本。格式为 $module => newmodule ，newmodule可以是本地磁盘的相对路径，例如http://github.com/gin-gonic/gin => ./gin。也可以是本地磁盘的绝对路径，例如http://github.com/gin-gonic/gin => /home/lk/gin。还可以是网络路径，例如http://golang.org/x/text v0.3.2 => http://github.com/golang/text v0.3.2。

### 二：语义版本号:(借鉴，语义化版本2.0.0)

#### 1.摘要：

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：

- 主版本号：当你做了不兼容的 API 修改，

- 次版本号：当你做了向下兼容的功能性新增，

- 修订号：当你做了向下兼容的问题修正。

<mark>：先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</mark>



###### 1.主版本号：

1. **更改API端点**：如果API的URL路径或查询参数发生了变化，导致旧的端点不再可用或行为发生变化，这通常需要升级主版本号。
   <mark>（端口通常是指在同一个接口中提供特定功能子集的服务提供者）</mark>

2. **更改请求或响应的数据结构**：如果API的请求参数或响应数据结构发生了重大变化，比如删除了某个字段，或者改变了字段的数据类型，这也可能需要升级主版本号。

3. **更改业务逻辑**：如果API的业务逻辑发生了变化，比如计算结果的方式发生了改变，或者某些功能被完全移除，这通常需要升级主版本号。

4. **更改依赖关系**：如果API依赖的库或服务发生了不兼容的变更，导致API的行为发生变化，这可能也需要升级主版本号。

5. **安全性更新**：如果API进行了重要的安全更新，这些更新可能会影响到现有的实现，因此可能需要升级主版本号。

6. **性能优化**：在某些情况下，如果性能优化导致API的行为在极端情况下有所不同，也可能需要升级主版本号。
   
   

###### 2.次版本号：

1. **新增功能**：在不改变现有API行为的前提下，增加新的功能或API端点。例如，增加一个新的API端点来支持新的业务需求。

2. **改进现有功能**：在不改变现有API行为的前提下，改进现有功能的性能或用户体验。例如，优化一个API端点的响应时间。

3. **增加新的参数**：在API请求中增加新的可选参数，但不影响现有参数的使用。例如，增加一个新的查询参数来支持更复杂的查询条件。

4. **增加新的返回字段**：在API响应中增加新的可选字段，但不影响现有字段的使用。例如，增加一个新的字段来返回额外的信息。

5. **增加新的数据类型**：在API中增加新的数据类型，但不影响现有数据类型。例如，增加一个新的枚举类型来表示更多的状态。

6. **增加新的配置选项**：在API中增加新的配置选项，但不影响现有配置的使用。例如，增加一个新的配置选项来控制API的行为。

7. **增加新的安全特性**：在不改变现有API行为的前提下，增加新的安全特性。例如，增加一个新的安全特性来增强API的安全性。
   
   

###### 3.修订号：

1. **修复bug**：如果API的一个端点在特定情况下返回了错误的数据或抛出了异常，开发者可以发布一个新的修订版本来修复这个问题。例如，如果API版本1.2.0中的一个端点由于类型转换错误导致在某些输入下崩溃，开发者可以发布1.2.1版本来修复这个问题。

2. **更新文档**：有时候，修订号的变更可能仅仅是为了**更新API的文档**，使其更加清晰或准确，**而API的实际代码并没有变化**。例如，开发者可能发现1.2.0版本的文档中有一个误导性的例子，并在1.2.1版本中对其进行了修正。

3. **性能优化**：如果开发者发现API在处理某些请求时效率不高，他们可以在**不改变API行为的前提下对其进行优化**，并发布一个新的修订版本。例如，1.2.0版本的API在处理大量数据时响应较慢，开发者对其进行了性能优化，并发布了1.2.1版本。

4. **安全修复**：安全问题通常需要紧急修复，即使这些**修复不涉及API行为的改变**。例如，如果1.2.0版本的API存在一个安全漏洞，允许未经授权的访问，开发者可以发布1.2.1版本来修复这个漏洞。

5. **依赖项更新**：如果API依赖的库或框架发布了安全或性能相关的更新，API的开发者可能会发布一个新的修订版本来集成这些更新。例如，如果API使用了某个第三方库，该库发布了一个修复关键安全漏洞的更新，API的开发者可能会发布1.2.1版本来集成这个更新。

6. **内部重构**：有时候，开发者可能需要对API的内部实现进行重构，以提高代码的可维护性或可扩展性。只要这种**重构不改变API的公共接口和行为**，它就可以通过修订号变更来发布。例如，开发者可能重构了1.2.0版本的代码，使其更加模块化，然后发布了1.2.1版本。
   
   

###### 4.API：（假设）：

1. **菜单（API文档）**：上面列出了可以点的所有菜品（功能），每道菜的描述（如何使用功能），可能还有推荐的配料搭配（参数说明）。

2. **点菜（发送请求）**：告诉服务员（通过编程代码或工具）想要什么菜，可能还要告诉服务员你的特别要求，比如不要香菜、少盐等（设置请求参数）。

3. **服务员记录（API密钥）**：服务员会确认你的身份（通过你的点菜方式或桌号），这就像是API密钥，用来确认你是合法的顾客，有权点菜。

4. **厨师做菜（处理请求）**：服务员把你的点菜信息告诉厨师（服务器），厨师根据要求做菜。

5. **上菜（响应）**：菜做好后，服务员把菜端给你，你享用美食（得到API返回的数据）。

6. **反馈（错误处理）**：如果菜上错了或者不符合你的要求，服务员会帮你解决，这就像是API调用中的错误处理。

：更加详细的知识，请移转：[如何理解API，API 是如何工作的-CSDN博客**](https://blog.csdn.net/cumtdeyurenjie/article/details/80211896?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522172222199416800178569010%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=172222199416800178569010&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80211896-null-null.142^v100^control&utm_term=API&spm=1018.2226.3001.4187)

（API！=接口）



#### 2.语义化版本控制规范：

<mark>关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。</mark>

- 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整

- 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0

- 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行

- 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版

- 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容

- 修订号 Z（x.y.Z `|` x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改

- 次版本号 Y（x.Y.z `|` x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零

- 主版本号 X（X.y.z `|` X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零

- 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 **ASCII 字母数字**和连接号 [0-9,A-Z,a-z] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92
  
  <mark>：`1.0.0-alpha`：表示主版本1，次版本0，修订号0的alpha版本，这是一个非常早期的预览版本</mark>

       <mark> ：`1.0.0-alpha.1`：在alpha版本的基础上增加了一个修订，可能表示进行了一些小的更新或修复</mark>

    <mark>     ：`1.0.0-0.3.7`：表示有一个更具体的先行版本划分，可能用于标识不同的构建或里程碑。</mark>

      <mark>   ：`1.0.0-x.7.z.92`：这里的"x"、"7"、"z"和"92"是自定义的标识符，用于表示特定的预发布版本或构建。</mark>

- 版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9,A-Z,a-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85
  
  <mark>：`1.0.0-alpha+001`：表示主版本1，次版本0，修订号0的alpha先行版本的一个特定构建，其中"001"是构建的标识符</mark>
  
  <mark>：`1.0.0+20130313144700`：表示主版本1，次版本0，修订号0的一个标准版本，构建时间戳为"20130313144700"</mark>
  
  <mark>：`1.0.0-beta+exp.sha.5114f85`：表示主版本1，次版本0，修订号0的beta先行版本，构建标识符为"exp.sha.5114f85"，可能表示这是一个基于特定提交哈希的实验性构建。</mark>

- 版本的优先层级指的是不同版本在排序时如何比较。
  
  1. 判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
  
  2. 由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。
     例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
  
  3. 当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。
     例如：1.0.0-alpha < 1.0.0。
  
  4. 有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：
     
     1. 只有数字的标识符以数值高低比较。
     
     2. 有字母或连接号时则逐字以 ASCII 的排序来比较。
     
     3. 数字的标识符比非数字的标识符优先层级低。
     
     4. 若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
  
    例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
  
  

# 


